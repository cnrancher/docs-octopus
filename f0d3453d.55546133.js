(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{143:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return c})),a.d(t,"metadata",(function(){return b})),a.d(t,"rightToc",(function(){return o})),a.d(t,"default",(function(){return s}));var n=a(2),r=a(6),i=(a(0),a(148)),c={id:"mqtt-extension",title:"Integrate with MQTT"},b={id:"en/adaptors/mqtt-extension",title:"Integrate with MQTT",description:"Octopus provides two out-of-box ways to integrate with [MQTT](http://mqtt.org/):",source:"@site/docs/en/adaptors/mqtt-extension.md",permalink:"/docs-octopus/docs/en/adaptors/mqtt-extension",editUrl:"https://github.com/cnrancher/docs-octopus/edit/master/website/docs/en/adaptors/mqtt-extension.md",sidebar:"docs",previous:{title:"Dummy Adaptor",permalink:"/docs-octopus/docs/en/adaptors/dummy"},next:{title:"How to Develop Adaptor",permalink:"/docs-octopus/docs/en/adaptors/develop"}},o=[{value:"MQTT",id:"mqtt",children:[{value:"Convention",id:"convention",children:[]}]},{value:"Configuration",id:"configuration",children:[{value:"Specification",id:"specification",children:[]},{value:"Specification YAML",id:"specification-yaml",children:[]},{value:"Status",id:"status",children:[]}]},{value:"Supported Adaptors",id:"supported-adaptors",children:[]}],l={rightToc:o};function s(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(n.a)({},l,a,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Octopus provides two out-of-box ways to integrate with ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"http://mqtt.org/"}),"MQTT"),":"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Most Octopus adaptors, like ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./ble"}),"BLE adaptor")," support to synchronize the device status via an MQTT broker. Get more MQTT extension adaptors ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"#supported-adaptors"}),"below"),"."),Object(i.b)("li",{parentName:"ol"},"If the device naturally supports MQTT, the ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./mqtt"}),"MQTT adaptor")," can be used as the first choice.")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"This post mainly outlines the detail of the first way, if you want to know more about the MQTT adaptor, please view ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"./mqtt"}),"here"),". If the above out-of-box ways cannot satisfy you, you can follow the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"../../CONTRIBUTING.md"}),"CONTRIBUTING")," to contribute your idea or ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"./develop.md"}),"develop a new adaptor"),".")),Object(i.b)("p",null,"Although the latest version of MQTT is v5.0, for the time being, Octopus does not support the revision, the main reason is the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.eclipse.org/paho/clients/golang/"}),"corresponding development library")," does not support yet(",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/eclipse/paho.mqtt.golang/issues/347"}),"paho.mqtt.golang/issues#347"),"):"),Object(i.b)("ul",{className:"contains-task-list"},Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(n.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html"}),"MQTT 3.1")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(n.a)({parentName:"li"},{type:"checkbox",checked:!0,disabled:!0}))," ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html"}),"MQTT 3.1.1")),Object(i.b)("li",Object(n.a)({parentName:"ul"},{className:"task-list-item"}),Object(i.b)("input",Object(n.a)({parentName:"li"},{type:"checkbox",checked:!1,disabled:!0}))," ",Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"https://docs.oasis-open.org/mqtt/mqtt/v5.0/mqtt-v5.0.html"}),"MQTT 5.0"))),Object(i.b)("p",null,"Integrating with MQTT to expose the status of a device, in addition to giving the device an ability to use MQTT, can also expand the usage scenarios of the device, such as equipment interaction and equipment monitoring."),Object(i.b)("h2",{id:"mqtt"},"MQTT"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},'MQTT is a machine-to-machine (M2M)/"Internet of Things" connectivity protocol. It was designed as an extremely lightweight publish/subscribe messaging transport. It is useful for connections with remote locations where a small code footprint is required and/or network bandwidth is at a premium.')),Object(i.b)("p",null,'Although MQTT\'s name contains "MQ", it is not a protocol for defining a message queue, actually, ',Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.hivemq.com/blog/mqtt-essentials-part2-publish-subscribe/#distinction-from-message-queues"}),'the "MQ" refers to the MQseries product from IBM and has nothing to do with "Message Queue"'),". MQTT is a lightweight and binary protocol, and due to its minimal packet overhead, MQTT excels when transferring data over the wire in comparison to protocols like HTTP. MQTT provides a means of communication that can be pub/sub like a message queue, at the same time, many features are provided to enrich communication scenarios, such as QoS, Last will and testament, retained message and so on. To learn more about MQTT, there are a series of articles that are highly recommended: ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.hivemq.com/mqtt-essentials/"}),"MQTT Essentials"),"."),Object(i.b)("p",null,Object(i.b)("img",Object(n.a)({parentName:"p"},{src:"https://www.hivemq.com/img/blog/mqtt-tcp-ip-stack.png",alt:"mqtt-tcp-ip-stack"}))),Object(i.b)("h3",{id:"convention"},"Convention"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("strong",{parentName:"p"},"MQTT uses subject-based filtering of messages"),". ",Object(i.b)("strong",{parentName:"p"},"Every message contains a topic (subject)")," that the broker can use to determine whether a subscribing client gets the message or not. ")),Object(i.b)("p",null,"In MQTT, the ",Object(i.b)("strong",{parentName:"p"},"topic")," is a hierarchically-structured string that can be used to ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/"}),"filter and route messages")," and the ",Object(i.b)("strong",{parentName:"p"},"payload")," data is agnostic which means the publisher can send binary data, text data, or even full-fledged XML or JSON, so designing the topic tree and payload schema is an important work of any MQTT deployment."),Object(i.b)("p",null,"Octopus follows the ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.hivemq.com/blog/mqtt-essentials-part-5-mqtt-topics-best-practices/#best-practices"}),"best practices of MQTT topic from MQTT Essentials")," to construct the ",Object(i.b)("strong",{parentName:"p"},"topic")," name, and marshals the ",Object(i.b)("strong",{parentName:"p"},"payload")," data as JSON."),Object(i.b)("h2",{id:"configuration"},"Configuration"),Object(i.b)("p",null,"Octopus reorganizes the client parameters of ",Object(i.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/eclipse/paho.mqtt.golang/blob/4c98a2381d16c21ed2f9f131cec2429b0348ab0f/options.go#L53-L87"}),"github.com/eclipse/paho.mqtt.golang"),", and then constructs the following configuration options. The available version of the configuration options is ",Object(i.b)("inlineCode",{parentName:"p"},"v1alpha1"),"."),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Versions"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Available"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Current"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"./integrate_with_mqtt.md"}),Object(i.b)("inlineCode",{parentName:"a"},"v1alpha1"))),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"*"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"*")))),Object(i.b)("p",null,"The current official Adaptors such as BLE, Modbus and OPC-UA support the MQTT protocol extension using the same configuration (refer to the following ",Object(i.b)("inlineCode",{parentName:"p"},"spec.template.spec.extension"),")."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-YAML"}),'apiVersion: edge.cattle.io/v1alpha1\nkind: DeviceLink\nmetadata:\n name: living-room-fan\nspec:\n adaptor:\n   node: edge-worker\n   name: adaptors.edge.cattle.io/dummy\n model:\n   apiVersion: "devices.edge.cattle.io/v1alpha1"\n   kind: "DummySpecialDevice"\n template:\n   metadata:\n     labels:\n       device: living-room-fan\n   spec:\n     extension:\n       mqtt:\n         client:\n           server: tcp://test.mosquitto.org:1883\n           maxReconnectInterval: 20s\n         message:\n           topic:\n             prefix: cattle.io/octopus\n           qos: 1\n     protocol:\n       location: "living_room"\n     gear: slow\n     "on": true\n')),Object(i.b)("h3",{id:"specification"},"Specification"),Object(i.b)("p",null,"The specification of MQTT options are valid in all MQTT extension adaptors, they are using for connecting the MQTT broker, guiding the connection, indicating which topic to publish/subscribe and encoding of payload data."),Object(i.b)("h4",{id:"deviceextensionspec"},"DeviceExtensionSpec"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"mqtt"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the MQTT settings."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttoptionsspec"}),"MQTTOptionsSpec")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttoptionsspec"},"MQTTOptionsSpec"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"client"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the client settings."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttclientoptions"}),"MQTTClientOptions")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"message"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the message settings."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttmessageoptions"}),"MQTTMessageOptions")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")))),Object(i.b)("h4",{id:"mqttclientoptions"},"MQTTClientOptions"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"server"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the server URI of MQTT broker, the format should be ",Object(i.b)("inlineCode",{parentName:"td"},"schema://host:port"),". The ",Object(i.b)("inlineCode",{parentName:"td"},"schema"),' is one of the "ws", "wss", "tcp", "unix", "ssl", "tls" or "tcps".'),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"protocolVersion"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the MQTT protocol version that the cluster uses to connect to broker. Legitimate values are 3 - MQTT 3.1 and 4 - MQTT 3.1.1"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"uint"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"will"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the last will message that the client gives it to the broker."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttclientwillmessage"}),"MQTTClientWillMessage")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"basicAuth"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the username and password that the client connects to the MQTT broker."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttclientbasicauth"}),"MQTTClientBasicAuth")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"tlsConfig"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the TLS configuration that the client connects to the MQTT broker."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttclienttls"}),"MQTTClientTLS")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"cleanSession"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),'Specifies setting the "clean session" flag in the connect message that the MQTT broker should not, default to ',Object(i.b)("inlineCode",{parentName:"td"},"true"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"store"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies to provide message persistence in cases where QoS level is 1 or 2, the default store is ",Object(i.b)("inlineCode",{parentName:"td"},"memory"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttclientstore"}),"MQTTClientStore")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"resumeSubs"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies to enable resuming of stored (un)subscribe messages when connecting but not reconnecting. This is only valid if ",Object(i.b)("inlineCode",{parentName:"td"},"CleanSession")," is false. The default value is ",Object(i.b)("inlineCode",{parentName:"td"},"false"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"connectTimeout"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client try to open a connection to an MQTT broker before timing out and getting error. A duration of 0 never times out. The default value is ",Object(i.b)("inlineCode",{parentName:"td"},"30s"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"keepAlive"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client should wait before sending a PING request to the broker. The default keep alive is ",Object(i.b)("inlineCode",{parentName:"td"},"10s"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"pingTimeout"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client should wait after sending a PING request to the brokerThe default value is ",Object(i.b)("inlineCode",{parentName:"td"},"10s"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"order"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),'Specifies the message routing to guarantee order within each QoS level. The default value is  "true".'),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"writeTimeout"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client publish a message successfully before getting a timeout error, default to ",Object(i.b)("inlineCode",{parentName:"td"},"30s"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"autoReconnect"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Configures using the automatic reconnection logic, default to ",Object(i.b)("inlineCode",{parentName:"td"},"true"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"maxReconnectInterval"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client should wait before reconnecting to the broker, default to ",Object(i.b)("inlineCode",{parentName:"td"},"10m"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"messageChannelDepth"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the size of the internal queue that holds messages while the client is temporarily offline, default to ",Object(i.b)("inlineCode",{parentName:"td"},"100"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"uint"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"httpHeaders"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the additional HTTP headers that the client sends in the WebSocket opening handshake."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"map","[string][]","string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttclientwillmessage"},"MQTTClientWillMessage"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"topic"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),'Specifies the topic for publishing the last will message. if not set, the will topic will append "$will" to the topic name specified in global settings as its topic name.'),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"payloadEncode"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Defines the encoded method of publishing message, options are ",Object(i.b)("inlineCode",{parentName:"td"},"raw")," and ",Object(i.b)("inlineCode",{parentName:"td"},"base64"),", default to raw."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"payloadContent"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the payload content."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"qos"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the QoS of the message, default value is ",Object(i.b)("inlineCode",{parentName:"td"},"0"),". options are 0, 1, 2."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"byte"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"retained"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the message to be retained,  default value is ",Object(i.b)("inlineCode",{parentName:"td"},"false"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttclientbasicauth"},"MQTTClientBasicAuth"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"name"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"MQTT server basic auth username."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"password"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"MQTT broker basic auth password."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttclienttls"},"MQTTClientTLS"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"caFilePem"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"The PEM format content of the CA certificate, which is used for validate the server certificate with."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"caFilePemRef"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the relationship of DeviceLink's references to refer to the value as the CA file PEM content ."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#devicelinkreferencerelationship"}),"DeviceLinkReferenceRelationship")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"certFilePem"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"The PEM format content of the certificate, which is used for client authenticate to the server."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"certFilePemRef"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the relationship of DeviceLink's references to refer to the value as the client certificate file PEM content ."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#devicelinkreferencerelationship"}),"DeviceLinkReferenceRelationship")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"keyFilePem"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"The PEM format content of the key, which is used for client authenticate to the server."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"keyFilePemRef"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the relationship of DeviceLink's references to refer to the value as the client key file PEM content."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#devicelinkreferencerelationship"}),"DeviceLinkReferenceRelationship")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"serverName"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Indicates the name of the server, ref to ",Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"http://tools.ietf.org/html/rfc4366#section-3.1"}),"http://tools.ietf.org/html/rfc4366#section-3.1")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"insecureSkipVerify"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Doesn't validate the server certificate, default value is ",Object(i.b)("inlineCode",{parentName:"td"},"false"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"devicelinkreferencerelationship"},"DeviceLinkReferenceRelationship"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"name"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the k8s resource name of the reference(currently only support k8s secret and configmap within the same namespace)."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"item"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the item name of the referred reference."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")))),Object(i.b)("h4",{id:"mqttclientstore"},"MQTTClientStore"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"type"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the type of storage. Options are ",Object(i.b)("inlineCode",{parentName:"td"},"memory")," and ",Object(i.b)("inlineCode",{parentName:"td"},"file"),", the default value is ",Object(i.b)("inlineCode",{parentName:"td"},"memory"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"direcotryPrefix"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the directory prefix of the storage, if using file store. The default value is ",Object(i.b)("inlineCode",{parentName:"td"},"/var/run/octopus/mqtt"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttmessageoptions"},"MQTTMessageOptions"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"topic"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the topic settings."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(i.b)("a",Object(n.a)({parentName:"td"},{href:"#mqttmessagetopic"}),"MQTTMessageTopic")),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"true")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"payloadEncode"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Defines the encoded method of publishing message, options are ",Object(i.b)("inlineCode",{parentName:"td"},"raw")," and ",Object(i.b)("inlineCode",{parentName:"td"},"base64"),", default to raw."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"qos"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the QoS of the message, default value is ",Object(i.b)("inlineCode",{parentName:"td"},"0"),". options are 0, 1, 2."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"byte"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"retained"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the message to be retained,  default value is ",Object(i.b)("inlineCode",{parentName:"td"},"false"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"bool"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"waitTimeout"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the amount of time that the client should wait after operating, default value to ",Object(i.b)("inlineCode",{parentName:"td"},"0s")," - never times out."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h4",{id:"mqttmessagetopic"},"MQTTMessageTopic"),Object(i.b)("table",null,Object(i.b)("thead",{parentName:"table"},Object(i.b)("tr",{parentName:"thead"},Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Schema"),Object(i.b)("th",Object(n.a)({parentName:"tr"},{align:"center"}),"Required"))),Object(i.b)("tbody",{parentName:"table"},Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"name"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the static name of topic - (default to use this static name if both ",Object(i.b)("inlineCode",{parentName:"td"},"name")," and ",Object(i.b)("inlineCode",{parentName:"td"},"prefix")," are configured)."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"prefix"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the prefix for the dynamic name of topic. The prefix is required for dynamic name."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")),Object(i.b)("tr",{parentName:"tbody"},Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"with"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specifies the mode for the dynamic name of topic. Options are ",Object(i.b)("inlineCode",{parentName:"td"},"nn"),"(k8s name+namespace) and ",Object(i.b)("inlineCode",{parentName:"td"},"uid"),"(k8s resource uid), the default mode is ",Object(i.b)("inlineCode",{parentName:"td"},"nn"),"."),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"string"),Object(i.b)("td",Object(n.a)({parentName:"tr"},{align:"center"}),"false")))),Object(i.b)("h3",{id:"specification-yaml"},"Specification YAML"),Object(i.b)("p",null,"The specification of MQTT options are valid in all MQTT extension adaptors, they are using for connecting the MQTT broker server, guiding the connection, indicating which topic to publish/subscribe and encoding of payload data and so on."),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"REQUIRED is the required field to be filled.")),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),'\n# Specifies the client settings.\nclient:\n\n  # Specifies the server URI of MQTT broker, the format should be `schema://host:port`.\n  # The "schema" is one of the "ws", "wss", "tcp", "unix", "ssl", "tls" or "tcps".\n  # REQUIRED\n  server: <string>\n  \n  # Specifies the MQTT protocol version that the cluster uses to connect to broker.\n  # Legitimate values are currently 3 - MQTT 3.1 or 4 - MQTT 3.1.1.\n  protocolVersion: <int, 3|4>\n  \n  # Specifies the will message that the client gives it to the broker,\n  # which can be published to any clients that are subscribed the provided topic.\n  will:\n  \n    # Specifies the topic for publishing the will message,\n    # if not set, the will topic will append "$will" to the topic name specified\n    # in global settings as its topic name.\n    topic: \n      \n      # Specifies the static name of topic.\n      name: <string>\n  \n    # Specifies the encode way of payload content.\n    #   raw: Not encode.\n    #   base64: The output (published) data is encoded with Base64, and the input (subscribed) data is decoded with Base64. \n    # The "base64" way allows to input bytes (`payloadContent`) that cannot be characterized.\n    # The default way is "raw".\n    payloadEncode: <string, raw|base64>\n\n    # Specifies the payload content.\n    # REQUIRED\n    payloadContent: <string>\n  \n    # Specifies the QoS of the will message.\n    #   0: Send at most once.\n    #   1: Send at least once.\n    #   2: Send exactly once.\n    # The default value is "0".\n    qos: <int, 0|1|2>\n  \n    # Specifies the will message to be retained.\n    # The default value is "false".\n    retained: <bool>\n  \n  # Specifies the username and password that the client connects\n  # to the MQTT broker. Without the use of `tlsConfig`,\n  # the account information will be sent in plaintext across the wire.\n  basicAuth:\n    name: <string>\n    passsword: <string>\n  \n  # Specifies the TLS configuration that the client connects to the MQTT broker.\n  tlsConfig:\n    \n    # The PEM format content of the CA certificate,\n    # which is used for validate the server certificate with.\n    caFilePem: <string>\n    \n    # The PEM format content of the certificate and key,\n    # which is used for client authenticate to the server.\n    certFilePem: <string>\n    keyFilePem: <string>\n    \n    # Indicates the name of the server, ref to http://tools.ietf.org/html/rfc4366#section-3.1.\n    serverName: <string>\n  \n    # Doesn\'t validate the server certificate.\n    insecureSkipVerify: <bool>\n\n  # Specifies setting the "clean session" flag in the connect message that the MQTT broker should not\n  # save it. Any messages that were going to be sent by this client before disconnecting previously but didn\'t send upon connecting to the broker.\n  # The default value is "true".\n  cleanSession: <bool>\n  \n  # Specifies to provide message persistence in cases where QoS level is 1 or 2.\n  # The default store is "memory".\n  store: \n    \n    # Specifies the type of storage.\n    # The default store is "memory".\n    type: <string, memory|file>\n    \n    # Specifies the directory prefix of the storage, if using file store.\n    # The default value is "/var/run/octopus/mqtt".\n    direcotryPrefix: <string>\n\n  # Specifies to enable resuming of stored (un)subscribe messages when connecting but not reconnecting.\n  # This is only valid if `cleanSession` is false.\n  # The default value is "false".\n  resumeSubs: <bool>\n\n  # Specifies the amount of time that the client try to open a connection\n  # to an MQTT broker before timing out and getting error.\n  # A duration of 0 never times out.\n  # The default value is "30s".\n  connectionTime: <string>\n\n  # Specifies the amount of time that the client should wait\n  # before sending a PING request to the broker. This will\n  # allow the client to know that the connection has not been lost\n  # with the server.\n  # A duration of 0 never keeps alive.\n  # The default keep alive is "30s".\n  keepAlive: <string>\n\n  # Specifies the amount of time that the client should wait\n  # after sending a PING request to the broker. This will\n  # allow the client to know that the connection has been lost\n  # with the server.\n  # A duration of 0 may cause unnecessary timeout error.\n  # The default value is "10s".\n  pingTimeout: <string>\n  \n  # Specifies the message routing to guarantee order within each QoS level. If set to false,\n  # the message can be delivered asynchronously from the client to the application and\n  # possibly arrive out of order.\n  # The default value is "true".\n  order: <bool>\n  \n  # Specifies the amount of time that the client publish a message successfully before\n  # getting a timeout error.\n  # A duration of 0 never times out.\n  # The default value is "30s".\n  writeTimeout: <string>\n  \n  # Configures using the automatic reconnection logic.\n  # The default value is "true".\n  autoReconnect: <bool>\n  \n  # Specifies the amount of time that the client should wait\n  # before reconnecting to the broker. The first reconnect interval is 1 second,\n  # and then the interval is incremented by *2 until `MaxReconnectInterval` is reached.\n  # This is only valid if `AutoReconnect` is true.\n  # A duration of 0 may trigger the reconnection immediately.\n  # The default value is "10m".\n  maxReconnectInterval: <string>\n\n  # Specifies the size of the internal queue that holds messages\n  # while the client is temporarily offline, allowing the application to publish\n  # when the client is reconnected.\n  # This is only valid if `autoReconnect` is true.\n  # The default value is "100".\n  messageChannelDepth: <int>\n  \n  # Specifies the additional HTTP headers that the client sends in the WebSocket opening handshake.\n  httpHeaders: <map[string][]string>\n\n# Specifies the message settings.\nmessage:\n    \n  # Specifies the topic settings.\n  # REQUIRED\n  topic:\n      \n    # Specifies the static name of topic.\n    name: <string>\n      \n    # Specifies the prefix for the dynamic name of topic.\n    # The prefix is REQUIRED for dynamic name.\n    prefix: <string>\n      \n    # Specifies the mode for the dynamic name of topic.\n    # The default mode is "nn".\n    with: <string, nn|uid>\n\n  # Specifies the encode way of payload data.\n  #   raw: Not encode.\n  #   base64: The output (published) data is encoded with Base64, and the input (subscribed) data is decoded with Base64.\n  # The default way is "raw".\n  payloadEncode: <string, raw|base64>\n\n  # Specifies the QoS of the will message.\n  #   0: Send at most once.\n  #   1: Send at least once.\n  #   2: Send exactly once.\n  # The default value is "0".\n  qos: <int, 0|1|2>\n\n  # Specifies the will message to be retained.\n  # The default value is "false".\n  retained: <bool>\n\n  # Specifies the amount of time that the client should wait after operating.\n  # A duration of 0 never times out.\n  # The default value is "0s".\n  waitTimeout: <string>\n\n')),Object(i.b)("h3",{id:"status"},"Status"),Object(i.b)("p",null,"The status of MQTT options are also valid in all MQTT extension adaptors, they are describing the observed status of the MQTT configuration."),Object(i.b)("pre",null,Object(i.b)("code",Object(n.a)({parentName:"pre"},{className:"language-yaml"}),'\n# Observes the client settings.\nclient:\n\n  # Observes the broker server URI.\n  server: <string>\n  \n  # Observes the protocol version.\n  protocolVersion: <int>\n\n  # Observes the will message that the client gives it to the broker.\n  will:\n\n    # Observes the topic for publishing the will message.\n    topicName: <string>\n    \n    # Observes the encode way of payload content.\n    payloadEncode: <string>\n\n    # Observes the QoS of the will message.\n    qos: <int>\n\n    # Observes if retaining the will message.\n    retained: <bool>\n\n  # Observes if configuring basic authentication.\n  configBasicAuth: <bool>\n\n  # Observes if configuring TLS.\n  configTLS: <bool>\n  \n  # Observes if setting the "clean session" flag.\n  cleanSession: <bool>\n\n  # Observes the store type.\n  store:\n\n     # Observes the type of storage.\n     type: <string>\n     \n     # Observes the directory of the file storage.\n     directory: <string>\n  \n  # Observes if enabling resuming of stored (un)subscribe messages when connecting but not reconnecting.\n  resumeSubs: <bool>\n\n  # Observes the amount of time that the client try to open a connection\n  # to an MQTT broker before timing out and getting error.\n  connectTimeout: <string>\n\n  # Observes the amount of time that the client should wait\n  # before sending a PING request to the broker.\n  keepAlive: <string>\n  \n  # Observes the amount of time that the client should wait\n  # after sending a PING request to the broker.\n  pingTimeout: <string>\n  \n  # Observes the message routing to guarantee order within each QoS level.\n  order: <bool>\n\n  # Observes the amount of time that the client publish a message successfully before getting a timeout error.\n  writeTimeout: <string>\n  \n  # Observes if using the automatic reconnection logic.\n  autoReconnect: <bool>\n  \n  # Observes the amount of time that the client should wait before reconnecting to the broker.\n  maxReconnectInterval: <int>\n\n  # Observes the size of the internal queue that holds messages while the client is temporarily offline, \n  # allowing the application to publish when the client is reconnected.\n  messageChannelDepth: <int>\n  \n  # Observes the additional HTTP headers that the client sends in the WebSocket opening handshake.\n  httpHeaders: <map[string][]string>\n \n# Observes the message settings. \nmessage:\n  \n  # Observes the topic for publishing/subscribing the message.\n  topicName: <string>\n  \n  # Observes the encode way of payload content.\n  payloadEncode: <string>\n\n  # Observes the QoS of the message.\n  qos: <int>\n  \n  # Observes if retaining the message.\n  retained: <bool>\n  \n  # Observes the amount of time that the client should wait after operating.\n  waitTimeout: <string>\n\n')),Object(i.b)("h2",{id:"supported-adaptors"},"Supported Adaptors"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./dummy"}),"dummy")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./ble"}),"ble")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./modbus"}),"modbus")),Object(i.b)("li",{parentName:"ul"},Object(i.b)("a",Object(n.a)({parentName:"li"},{href:"./opc-ua"}),"opcua"))))}s.isMDXComponent=!0},148:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return O}));var n=a(0),r=a.n(n);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function c(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function b(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?c(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):c(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=r.a.createContext({}),s=function(e){var t=r.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):b({},t,{},e)),a},p=function(e){var t=s(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=Object(n.forwardRef)((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,c=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),p=s(a),m=n,O=p["".concat(c,".").concat(m)]||p[m]||d[m]||i;return a?r.a.createElement(O,b({ref:t},l,{components:a})):r.a.createElement(O,b({ref:t},l))}));function O(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,c=new Array(i);c[0]=m;var b={};for(var o in t)hasOwnProperty.call(t,o)&&(b[o]=t[o]);b.originalType=e,b.mdxType="string"==typeof e?e:n,c[1]=b;for(var l=2;l<i;l++)c[l]=a[l];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);